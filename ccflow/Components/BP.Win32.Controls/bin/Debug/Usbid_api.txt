 目   录

第零章  公司及TELEWIND系列产品介绍

第一章  概述 
	     1.1  基本功能说明
	     1.2  性能特点介绍
             1.3  软硬件环境

第二章  硬件设置及安装 
            2.1  硬件说明
	    2.2  硬件设置
            2.3  安装步骤
            2.4  外部电缆连接
            2.5  模块说明

第三章  软件安装及运行 
            3.1  准备知识
            3.2  软件系统安装
            3.3  驱动程序的运行
           
第四章  C语言编程接口使用说明
            4.1  文件说明
            4.2  系统常量定义
            4.3  函数使用说明




第零章  公司及TELEWIND系列产品介绍 

   北京五岳鑫科技有限公司是一家民营高科技企业，公司聚集了一批高级技术人才，专业从事电话语音产品的研制和生产，产品的技术水准在国内处于领先水平，达到国际电话语音产品的先进水平，目前公司已形成模拟卡、数字卡、配套卡和功能模块四大系列多种型号产品，具体分类如下：
* 模拟接口电话语音卡
  TW8VF     八线电话语音（传真）卡
  TW8V-ID   八线主叫识别语音卡
  TW4V-ID   四线主叫识别语音卡
  TW8V      八线电话语音卡
  TW4V      四线电话语音卡
  TW2V      二线电话语音卡
  TW8R      八线专用录音卡
  USBID     两线主叫识别语音卡
* 数字中继接口语音卡
  TWPCM-60    60路数字中继卡
  TWPCM-30/1  1号信令数字中继卡
  TWPCM-7     7号信令数字中继卡
* 配套卡
  TW8F        八线传真卡
  TW4F        四线传真卡
  TWSLIC      八线座席卡
  TWCONF-64  电话会议卡
* 模块
  外线、内线、录音、放音、搭线、声控录音、磁石接口模块
    公司在提供品种多样的硬件产品的同时，更有丰富而强大的软件开发平台作支撑，TELEWIND系列语音产品提供DOS、WINDOWS3.X、UNIX、XINEX、WINDOWS 95、WINDOWS NT驱动程序，在程序接口方面，不仅有C语言，汇编语言接口，还有FOXPRO、VB、VC、DELPHI、PB语言接口，为用户提供足够的开发平台，缩短用户的应用程序开发周期。
TELEWIND系列语音产品已在以下系统得到广泛应用：
      自动通知/查询系统
      自动语音记录/调度系统
      自动预约系统
      电视台语音/传真查询系统
      电话银行系统
      语音、传真信箱系统
      电脑话务员/语音信箱
      公务信息交换系统
      高考查分系统
      114查号台
      112故障台
      200长途电话业务
      110公安报警接警系统		
      122交通事故报警接警系统				
      127寻呼台自动寻呼系统	














第一章   概述

    1.1 基本功能说明

    TeleWind 为系列电话语音产品，它包含有模拟电话语音处理卡和数字中继接口语音处理卡，本手册重点介绍模拟电话语音卡的安装及软件编程方法。 
    TeleWind的模拟语音卡有二线、四线、八线之分，除了二线卡之间不可互联外，四线、八线语音卡之间均可通过互联线联接而实现多达128路之间的交换。每一块卡都具有互相独立的多个通道，每个通道可根据需要配置成内线或外线；每一通道都可由软件编程完成如下基本功能：

   ★ 自动检测外线用户打进时的振铃信号和内线用户摘挂机动作；
   ★	可控制外线的摘挂机，内线的馈电或振铃；
   ★	将数字化电脑语音文件放送到电话线上；
   ★	将电话语音录制成数字化电脑语音文件；
   ★	接收用户的电话机按键信号，(双音频码)；
   ★	检测电话线路返回的各种信号音状态，如：拨号音、忙	音、回铃音等；
   ★	电话卡上任意两通道可连接相互通话。当卡上同时配有	内外线时，内外线间也可连接通话。该卡可实现程控机	的所有功能；
   ★	软件可调语音压缩比1:1--1:4；

    1.2 TELEWIND模拟电话语音卡性能特点介绍

   ★	TeleWind模拟电话语音卡采用标准程控机模块厚膜电，	母板则采用全数字化电路设计，使得整卡工作性能稳定	可靠，其电话线接口指标完全达到邮电部入网规范。
	    (邮电部入网证号 ：13―1004―970004)
   ★	TeleWind 采用先进模块化结构和最新大规模集成电路	设计，卡上可同时接多达8线电话，并且每块卡的总线	数和内外线比例可任意配置，灵活方便。
   ★	TeleWind 数字化语音采用电话通信领域的国际标准 A 	律 PCM 编码。此编码方式与其他电话卡所采用的线性	量化编码相比，具有动态范围大信噪比高,音质好，国际	标准化等特点。压缩编码则采用符合CCITT标准的	ADPCM编码方式。
   ★	TeleWind 的每一通道都可同时进行录音、放音和接收	用户电话机按键码。故用同一个电话机即可完成语音文	件的录制、编辑、重放，而无需象其他电话卡需要借助	其他工具和手段录音。
   ★	TeleWind 中任意两路电话都可连接相互通话， 故只要	每块卡上配置一条内线，即可为用户提供人工热线服		务。在一台机器安装多块卡时,可实现32线，最多128线	之间的无阻塞交换，该卡可实现程控机的所有功能。
	丰富的软件支持，包括DOS、UNIX、	XENIX、	WINDOWS3.X、WINDOWS 95、WINDOWS NT 环境		下的驱动程序及各种工具软件、演示程序。用户编程接	口简单易用，且生产厂家随时可为用户提供编程指导和	疑难解答, 热情周到的售后服务是我们对客户的永远承	诺。
　 ★	目前市场上的电话卡一般都功能单一，应用范围很窄。	但TeleWind 由于具有众多先进、优越的功能，可广泛	应用于证券业务电话委托、电话银行、信息查询、语音	信箱、自动传呼系统、多功能小型用户交换机等领域。


    1.3 软硬件环境

    1. 硬件要求
　  CPU 500MHz以上,USB1.1 以上兼容微机，。

    2. 软件环境
      A 软件平台
        WIN98、 WIN2000
      B 程序接口
	 C语言接口、VB、VC、PB、 Delphi
     第二章　　硬件设置及安装

警告：
    由于接入电话语音卡外线的电话线来自室外，如果走线不当，在雷雨等天气里会因雷电而感应出高电压。
    因雷击或模块插接不正确而造成的电话语音卡模块或母板损坏，不属于正常保修范围。
    在安装TeleWind 电话语音卡之前，请先仔细阅读本手册。本章将详细地指导你如何安装电话语音卡。

2.1  USBID硬件说明 

  1．硬件组成
    USBID由外置卡盒，USB接线组成。
    USBID卡可连接一条外线和一个内线(直接连接话柄)

       第三章  软件安装及运行

    3.1   预备知识

一、信号音：			
    TeleWind 电话语音卡具有信号音检测功能。信号音的情况有几十种，这里只介绍常用到的信号音的检测。
    1.对方挂机检测：
   当有外线拨入，TeleWind 检测到振铃信号之后，即摘机，这时就可进入人机交互功能。当对方挂机时，TeleWind 能检测到对方已经挂机的信号音状态，电话语音卡端接收到挂机忙音，其波形如下：
        0.5秒
　　  ┌──┐    ┌──┐    ┌──┐
　　  │    │0.5 │    │    │    │     ……
　　─┘    └──┘    └──┘    └──
    即0.5秒的“嘀”“嘀”声

    2.自动拨号检测：
    TeleWind 能够实现自动拨号，拨号完毕的信号音情况比较复杂。因为拨号完毕后，对方有可能占线，也可能没有人接听，或者有人接听等等。
　　当摘机以后，收到的是拨号音，其波形如下：

　　─────────────────────

　　当拨号完毕，对方话机占线时，TeleWind 收到的为被叫用户的忙音。其波形如下：

   0.35秒
　┌──┐    ┌──┐    ┌──┐
  │    │0.35│    │    │    │      ……
─┘    └──┘    └──┘    └──   
　　当拨号完毕，对方振铃时，TeleWind 收到的为回铃音，其波形如下：
   1秒
  ┌─┐        ┌─┐        ┌─┐
  │  │  4秒   │  │        │  │    ……
─┘  └────┘  └────┘  └── 
　　对于各种信号音，在函数库中有相应的检测函数。由于各种程控交换机的参数会有差别，用户可根据实际情况，自己调用函数改变信号音参数或增加新的信号音。TELEWIND还提供专门的信号音测试工具，帮助您处理各种非标准信号音。

　二. 双音多频(DTMF)码：
    双音多频信号,即DTMF(Dual Tone Multi-Frequency)广泛应用于电话拨号上。DTMF由CCITT 制定并推荐作为按键式电话的标准。DTMF由电话机的按键产生。
    DTMF信号实际是由两种音调的声音组合而成：低频和高频。DTMF信号是由两组频率合成，低频群：697、770、852、941(HZ)；高频群：1209、1336、1477、1633(HZ)。每一个DTMF信号由一个低频和一个高频组成，共产生16种信号。其具体定义见下表：
　　　　1209HZ   1336HZ  1477HZ       1633HZ
       ┌───┬───┬───┐   ┌───┐
697HZ  │ 1    │  2   │  3   │   │  A   │
       ├───┼───┼───┤   ├───┤
770HZ  │ 4    │  5   │  6   │   │  B   │
       ├───┼───┼───┤   ├───┤
852HZ  │ 7    │  8   │  9   │   │  C   │
       ├───┼───┼───┤   ├───┤
941HZ  │ *    │  0   │  #   │   │  D   │
       └───┴───┴───┘   └───┘
    双音频的接收由TeleWind 硬件来完成，并由底层驱动程序反映给应用程序。

三. 语音数字化及其压缩：
    任何一个语音处理系统所要考虑的很重要的一点是数字化语音所占空间的大小。采样率越高，数据量越大，存储空间占用的也越多。
    TeleWind 提供以下两种方法形成数字化语音，并减少存储空间。
 .ADPCM(Adaptive Differential Pulse  Code  Modulation)
 .A Law-PCM (Pulse    Code    Modulation )
    ADPCM 中，存储的不是语音的采样值，而是这一次采样与上一次采样值间的差值。由于语音信号的变化很慢，因此存储所需的空间也就相应减少。
　  PCM 由贝尔实验室开发,并成为公共电话网数字语音的世界统一标准。PCM包括有A率和μ率两种,μ率在北美洲一些国家使用,A率在世界其它国家和地区使用。TeleWind 采用的是适合我国国情的A率PCM编码。
    用户可以选择PCM或者ADPCM，TELEWIND在没有压缩(64,48KB/S) 的情况下,其编码方式采用PCM,反之则为ADPCM编码。欲了解PCM及ADPCM编码详情，请参阅有关书籍。

    3.2 软件系统安装：


第四章   C语言编程接口使用说明

4.1 文件说明 (适用于  WIN98, WIN2000)
软件包中文件说明
================

	FRECORD.C	- 编程范例
	FPLAY.C	- 编程范例
	CALL.C		- 编程范例
	LISTEN.C	- 编程范例

	USBID.H	- C 语言编程接口头文件
	USBID.DLL	- 函数接口动态库
	USBID.LIB	- 函数接口引入库

4.2  系统常量定义

FILE_FLAG	TV_VoiceLen 中放入 FILE_FLAG 表示TV_VoiceData 中是文件名
DTMF_LEN	每个通道在初始化后最多可接收的 DTMF 码 (24)

SIGNAL_TYPE	信号音种类数 (8)
SIG_UNKNOWN	未知的信号音 (0x60)
SIG_TIMEOUT	信号音检查超时 (0x61)
SIG_OFFHOOK	被呼叫方已经摘机 (0x62)
SIG_NOBODY	电话拨通之后无人接听 (0x63)
SIG_SILENCE	无信号音 (0x40)
SIG_DIAL	拨号音 (0x41)
SIG_RING	振铃回音 (0x00)
SIG_BUSY1	忙音 1 (0x01)
SIG_BUSY2	忙音 2 (0x02)


返回码常量定义
==============
E_DRIVER        0xff    -1  USBID 驱动没有起来   (TV_Installed调用结果)
E_OK            0x00    0   没有错误
E_COMMAND       0x01    1   错误命令/
E_LENGTH        0x02    2   缓冲区过大
E_PLAY_RECORD   0x03    3   放音与录音冲突
E_CHANNEL       0x04    4   错误的通道号
E_ARGUMENT      0x05    5   参数错误
E_ERR_SYNC      0x6     6   
E_OUT_OF_MEMORY 0x7     7   内存溢出
E_ERR           0x8     8
E_RECORD_BUSY   0x9     9   录音忙 
E_FILEOPEN      0xa     10  文件打开错误
E_PLAY_BUSY     0xb     11  放音忙


通道类型常量定义
================
CT_INTERNAL	内线通道
CT_EXTERNAL	外线通道
CT_EMPTY	空通道

压缩比常量定义
==============
RATE_64K	8K字节/秒 (目前只提供此压缩比)
RATE_32K	4K字节/秒
RATE_16K	2K字节/秒


数据类型定义
============

字符名称枚举类型
----------------

    字符名称类型用在 TV_MakeSentence(...) 中, 如果应用程序需要在放音时自动念
数字, 那么这个功能是很有用的. 其中 CN_NOTHING 不产生任何语音. 其定义如下:

typedef enum {
	CN_END = 0,	// End of sentence (Also end of string)
	CN_NOTHING,	// Do nothing
	CN_DIGIT0, CN_DIGIT1, CN_DIGIT2, CN_DIGIT3,   	CN_DIGIT4,	// 0 - 4
	CN_DIGIT5, CN_DIGIT6, CN_DIGIT7, CN_DIGIT8, 	CN_DIGIT9,	// 5 - 9
	CN_TEN,	//          10
	CN_HUNDRED,	//         100
	CN_THOUSAND,	//       1,000
	CN_10THOUSAND,//      10,000
	CN_100MILLION,	// 100,000,000
	CN_POINT,		// "."
	CN_NEGATIVE,		// "-"

	CN_LAST		// To be continued by YOU !
} CHAR_NAME;

    另外, 用户也可以在 CN_LAST 后扩展定义其他的字符名称, 例如

	typedef enum {
		UCN_USERDEF1 = CN_LAST,
		UCN_USERDEF2,
		...
		UCN_USERDEFn,
		UCN_LAST
	} USERDEF_CHAR_NAME;

参数控制块
----------
typedef struct {
	unsigned int	SilenceSigMin;// (125=5秒)无信号音的最短长度 (单位: 40ms)
	unsigned int	DialSigMin;	// ( 50=2秒)拨号音的最短长度 (单位: 40ms)
	unsigned int	SignalPara[SIGNAL_TYPE][4];
	// 各种信号音的时间参数 (单位: 40ms)
	// 其中第一个下标表示信号音类型, 用户可以定义信	号音类型 3 到 7
	//	[x][0] : 信号音为低时的最小时间
	//	[x][1] : 信号音为低时的最大时间
	//	[x][2] : 信号音为高时的最小时间
	//	[x][3] : 信号音为高时的最大时间
	//
	//   缺省值: [SIG_RING ][] = 90,110, 22, 28  (4,1 秒)
	//		[SIG_BUSY1][] =  7, 11,  7, 11  (0.35, 0.35 秒)
	//		[SIG_BUSY2][] = 11, 14, 11, 14  (0.5, 0.5 秒)
} PCB_STRUC;

系统参数结构  
------------
typedef struct {
	unsigned char	MajorVer;	// 驱动程序主版本号
	unsigned char	MinorVer;	// 驱动程序副版本号
	unsigned char	IRQNo;		// 第一块 USBID 的IRQ 设置
	unsigned char	IntrNo;		// IRQ 对应的中断号

	PCB_STRUC	PCB;		// 指向 PCB_STRUC的指针

	unsigned int	AdapterNum;	// 系统中安装的USBID卡的数量
	unsigned int	ChannelNum;	// 系统中可使用的通道数
	unsigned int	TW8VIDSeg[MAX_ADAPTERS]; // 每块 USBID 使用的段地址
} SP_STRUC;


变量定义
========
extern unsigned char	TV_ReturnCode;
TV_ReturnCode 是最近所调用函数的返回码. 在每次调用函数之后, 如果想判断
    函数是否正确执行, 可以把 TV_ReturnCode 和 <返回码常量定义> 进行比较.
    对于有些函数调用, 这是很必要的.

extern int	TV_CloseFile;

在调用 TV_StartPlayFile(...) 或 TV_StartRecordFile(...) 时, TV_CloseFile决定放音或录音过程中文件是否被关闭, 它的值为 0 表示不关闭文件, 为非 0 则表示关闭文件. 因为系统可同时打开的文件数是有限制的, 多个通道同时进行文件录音或放音时, 应考虑把 TV_CloseFile 设置成 1, 此时文件操作的速度会稍慢. TV_CloseFile 的缺省值是 0.  当文件被打开时, 使用的是共享方式 SH_DENYNO, 应用程序同时也可以用共享方式打开该文件.

extern char far *	*TV_VoiceData;
extern int	*TV_VoiceLen;

TV_VoiceData 和 TV_VoiceLen 用于 TV_PlaySentence(...), TV_VoiceData 中存放字符名称对应语音数据的长指针, 例如 TV_VoiceData[CN_DIGIT0] 指向 "0"的语音数据; TV_VoiceLen 中存放字符名对应语音数据的长度. TV_VoiceData 和TV_VoiceLen 中也应该包含用户定义的字符. 在调用 TV_PlaySentence(...) 前, 必须使这两个变量指向正确的数据. 如果 TV_VoiceLen[...] 中是 FILE_FLAG, 则表示相应的TV_VoiceData[...] 中存放的不是数据, 而是文件名. 请参看演
示程序 NPLAY.C

利用 TV_VoiceData 和 TV_VoiceLen, 调用TV_PlaySentence(...), 可以将一些分散的语音数据以及语音文件连接起来进行放音.

以上外部变量为与DOS兼容设置，没有用。
TV_ReturnCode 由函数TV_GetLastError()代替
TV_VoiceDataTV_VoiceLen为多文件放音使用，已由函数TV_SetVoicei代替。
TV_CloseFile 由于WIN95，WINNT没有因同时打开文件个数太多，而导致打开文件失败。
所以改变量没有设置。

注意：
以上外部变量为与DOS兼容设置，在WIN95，WINNT下没有用。
TV_ReturnCode 由函数TV_GetLastError()代替
TV_VoiceDataTV_VoiceLen为多文件放音使用，已由函数TV_SetVoicei代替。
TV_CloseFile 由于WIN95，WINNT没有因同时打开文件个数太多，而导致打开文件失败。
所以改变量没有设置。

函数原型
========

	初始化函数:

int	TV_Installed (void);
int	TV_Initialize (void);
int	TV_InitializeEx (int);   //新增函数
void	TV_Disable (void);

	检测及控制函数:

int	TV_ChannelType (int);
int	TV_OffHookDetect (int);
int	TV_RingDetect (int);
void	TV_HangUpCtrl (int);
void	TV_OffHookCtrl (int);
void	TV_RingCtrl (int);
void	TV_PowerCtrl (int);
void	TV_GenerateSignal (int, int);
void	TV_GenerateRing (int);

	录放音及收发 DTMF 码函数:
long	TV_StartRecord (int, char far *, int);
long	TV_StopRecord (int);
long	TV_RecordRest (int);
long	TV_StartPlay (int, char far *, int);
long	TV_StopPlay (int);
long	TV_PlayRest (int);
int 	TV_StartDial (int, char far *);
int 	TV_StopDial (int);
int 	TV_DialRest (int);
void	TV_FlushDTMF (int);
int 	TV_GetDTMFChar (int);
char far *TV_GetDTMFStr (int);

long	TV_StartRecordFile (int, char *, long, long);
long	TV_RecordFileRest (int);
long	TV_StopRecordFile (int);
long	TV_StartPlayFile (int, char *, long, long);
long	TV_PlayFileRest (int);
long	TV_StopPlayFile (int);

void	TV_MakeSentence (double, char *);
long	TV_PlaySentence (int, char *);
long	TV_PlaySentenceRest (int);

	通道连接交换函数:

void	TV_ConnectChannels (int, int);
void	TV_DisconnectChannels (int, int);
void	TV_ConnectTo (int, int);
void	TV_Disconnect (int);
void	TV_Connect3 (int, int, int);
void	TV_Disconnect3 (int, int, int);

	与信号音有关的函数:

int	TV_CheckSignal (int, int *, int *);
int	TV_ListenerOffHook (int);
void	TV_StartMonitor (int);
int	TV_MonitorOffHook (int, int);
int	TV_MonitorBusy (int, int, int);

	其他函数:

void	TV_StartTimer (int, long);
long	TV_TimerElapsed (int);
void	TV_SysPara (SP_STRUC far *);
void	TV_CompressRatio (int);
void	TV_GetSerial (char far *);

        新增函数:

int     TV_ReceiveCallingID (int , char far *,int);
void    TV_SetSignalLevel( int );
void    TV_SetChannelMode( int , int );
void    TV_SetVoicei(int ,char far *);
int     TV_GetLastError() ;

void    TV_SetSignalParam( int , int , int ,int ,int );
void    TV_SetDTMFSendSpeed( int , int );
int	 TV_SetOcTime(int t);		/* ***********99,1,20 */
int	 TV_SetOcInterval(int omin,int omax);
int	 TV_OcDetect(int ch);
int	 TV_InternalRingDetect( int ch );
int	 TV_SetVos( int v);
int	 TV_SetAmp(int v);	// 20 -- 80

4.3  函数功能说明

****注意: Telewind 的所有函数被调用后都立即返回 !

一．初始化函数:
int	TV_Installed (void);
----------------------------
功能: 判断 USBID 驱动程序驱动是否已经成功
参数: 无
返回: 系统中可使用的通道数 (0 : 驱动程序没有安装,3: 正常)
说明: 在应用程序启动时, 一定要先调用 TV_Installed(...)   来判断 USBID驱动程序是否已安
      装, 如果没有安装, 应用程序应该提示出错信息, 然后返回操作系统. 本函数不对电话卡进
      行初始化

int	TV_Initialize ();
-----------------------------
功能: 初始化系统中所有的 USBID 电话卡
参数: 
返回: 无
说明: 应用程序在调用 TV_Installed(...) 后, 一般可调用 TV_Initialize(...)对电话卡进行初
      始化. 初始化工作完成后, 所有外线都处于挂机状态, 内线处于馈电状态, 正在进行的录放
      音及收发DTMF 码等工作都被中止, 系统中断被打开, 准备处理各种函数调用工作
      与原来的TW8VID卡初始化函数兼容。


int	TV_InitializeEx (int);
-----------------------------
功能: 初始化系统中所有的 USBID 电话卡
参数: 0:查询方式，1：事件方式
返回: 无
说明: 应用程序在调用 TV_Installed(...) 后, 一般可调用 TV_Initialize(...)对电话卡进行初
      始化. 初始化工作完成后, 所有外线都处于挂机状态, 内线处于馈电状态, 正在进行的录放
      音及收发DTMF 码等工作都被中止, 系统中断被打开, 准备处理各种函数调用工作

void	TV_Disable (void);
--------------------------
功能: 禁止 USBID 工作
参数: 无
返回: 无
说明: 在 Telewind 应用程序退出前, 必须可调用此函数. TV_Diable(...) 首先进行初始化工作,
      然后关闭系统中断, 以后的所有函数调用都无效, 除非调用函数 TV_Initialize(...)
                                  
二．检测及控制函数:

int	TV_ChannelType (int);
-----------------------------
功能: 查询某一通道的类型
参数: 通道号
返回: 参阅 <通道类型常量定义>

int	TV_OffHookDetect (int);
-------------------------------
功能: 判断某一内线通道是否已摘机
参数: 通道号
返回: (0 : 挂机; 非 0 : 摘机)

int	TV_RingDetect (int);
----------------------------
功能: 判断某一外线通道是否在振铃
参数: 通道号
返回: (0 : 没有振铃; > 0 : 振铃次数)
说明: 在判断振铃前, 该外线通道应处于挂机状态. 另外, 由于振铃信号是断续的, USBID 驱动程
      序已经将它转换成连续的振铃信号, 这样, 振铃信号停止后的一小段时间内也可能检测到振
      铃信号, 应用程序中要考虑这种情况.  一次振铃结束后振铃次数加一。 

void	TV_HangUpCtrl (int);
----------------------------
功能: 控制某一外线通道挂机
参数: 通道号
返回: 无

void	TV_OffHookCtrl (int);
-----------------------------
功能: 控制某一外线通道摘机
参数: 通道号
返回: 无
说明: 对外线进行录放音, 收发 DTMF 码或信号检测前, 必须进行摘机操作

void TV_GenerateSignal (int, int);
----------------------------------
功能: 在某一通道产生信号音
参数: 1. 通道号
      2. 信号音类型 (参阅<系统常量定义>)
返回: 无
说明: 这里的信号音也可以是用户自定义的信号音, 如果信号音为 SIG_SILENCE, 则停止输出信号
      音

void TV_GenerateRing (int);
---------------------------
功能: 在某一通道输出自动断续的振铃
参数: 通道号
返回: 无
说明: 和 TV_RingCtrl(...) 一样, 调用 TV_PowerCtrl(...) 可以停止振铃

三．录放音及收发 DTMF 码函数:

long	TV_StartRecord (int, char far *, int);
------------------------------------------------
功能: 某一通道开始录音
参数: 1. 通道号
      2. 录音缓冲区指针
      3. 录音字节数 (小于 64K)
返回: 上次录音时还没有录完的字节数
说明: 各通道可以互不干扰, 独立进行录音, 调用TV_RecordRest(...) 判断是否录完.
      如果需要录音到某一数据文件, 建议调用 TV_StartRecordFile(...)在连续录音时要多次
      调用 TV_StartRecord(...), 建议缓冲区的长度为 512 字节的整数倍并且大于等于 1024 
      字节, 这样录音效果最佳

long	TV_StopRecord (int);
------------------------------------
功能: 强制停止某一通道的录音
参数: 通道号
返回: 停止录音时还没有录完的字节数
说明: 某一通道录音没有结束时可以用此函数强制停止录音
long	TV_RecordRest (int);
------------------------------------
功能: 查询某一通道有多少字节没有录完
参数: 通道号
返回: 没有录完的字节数, 如果为 0, 则表示录音结束

long	TV_StartPlay (int, char far *, int);
-------------------------------------------------------
功能: 某一通道开始放音
参数: 1. 通道号
      2. 放音缓冲区指针
      3. 放音字节数 (小于 64K)
返回: 上次放音时还没有放完的字节数
说明: 各通道可以互不干扰, 独立进行放音, 但是对某一个通道来说, 录音和放音不能同时进行,
      调用 TV_PlayRest(...) 判断是否放完.如果需要对某一数据文件进行放音, 建议调用
      TV_StartPlayFile(...)在连续放音时要多次调用 TV_StartPlay(...), 建议缓冲区的长度
      为 512 字节的整数倍并且大于等于 1024 字节, 这样放音效果最佳

long	TV_StopPlay (int);
----------------------------------
功能: 强制停止某一通道的放音
参数: 通道号
返回: 停止放音时还没有放完的字节数
说明: 某一通道放音没有结束时可以用此函数强制停止放音

long	TV_PlayRest (int);
----------------------------------
功能: 查询某一通道有多少字节没有放完
参数: 通道号
返回: 没有放完的字节数, 如果为 0, 则表示放音结束
说明: 如果返回为 0, 建议不要再调用 TV_StopPlay(...) 来强制停止放音

int 	TV_StartDial (int, char far *);
-----------------------------------------------
功能: 某一通道进行自动拨号
参数: 1. 通道号
      2. 拨号字符串
返回: 上次拨号时没有拨完的字符数
说明: 有效的拨号字符是 '0' - '9', '*', '#', 另外, 控制码 ',' 表示在拨号过程中延时 1 秒
      钟, 如果字符串中有无效的字符, 则在拨号时被忽略.
      TV_StartDial中号码串最长为DTMF_BUF_LEN(40)
      新增加脉冲拨号与拍叉簧动作，号码前加P，如TV_StartDial(0,"P355")
      号码前加T或不加任何字母，为音频拨号，如TV_StartDial(0,"T355"),
	,TV_StartDial(0,"68418887")，如要产生拍叉簧动作，即调用TV_StartDial(0,"PR"),
	紧接着拨号调用TV_StartDial(0,"PRT355"),
      设置拍叉簧的时间调用函数 TV_SetOcTime。
	

int 	TV_StopDial (int);
----------------------------------
功能: 停止某一通道的自动 DTMF 拨号
参数: 通道号
返回: 没有拨完的字符数

int 	TV_DialRest (int);
----------------------------------
功能: 查询某一通道有多少字节没有拨完
参数: 通道号
返回: 没有拨完的字节数, 如果为 0, 则表示自动 DTMF 拨号结束
说明: 自动拨号后一般要调用TV_StartTimer(...), TV_MonitorOffHook(...) 或TV_ListenerOffHook(...) 
      来判断被呼叫方是否已经摘机, 在这种情况下, 一定要在TV_DialRest(...) 返回为 0, 也即
      自动拨号结束后, 才能够调用 TV_StartTimer(...), 否则, 计时器的时间中就会包括拨号的时间,
      从而影响摘机检查的结果. 请参看演示程序 TVCALL.C

void	TV_FlushDTMF (int);
---------------------------
功能: 清除某一通道的 DTMF 接收缓冲区
参数: 通道号
返回: 无
说明: 号码接收缓冲区最长为DTMF_BUF_LEN，若没有及时取出，可能会丢失。


int	TV_GetDTMFChar (int);
-----------------------------
功能: 获取某一通道接收到的一个 DTMF 字符
参数: 通道号
返回: 接收到的 DTMF 字符
说明: 如果返回 -1, 则表示没有接收到 DTMF 字符

char far *TV_GetDTMFStr (int);
------------------------------
功能: 获取某一通道接收到的 DTMF 字符串
参数: 通道号
返回: DTMF 字符串指针
说明: 内部缓冲区最多只能容纳 24 个 DTMF 字符, 如果应用程序需要接收更多的字符, 可以调用
      TV_GetDTMFChar(...) 将字符放到自定义缓冲区中进行处理

long	TV_StartRecordFile (int, char *, long, long);
-----------------------------------------------------
功能: 对某一通道进行文件录音
参数: 1. 通道号
      2. 数据文件名
      3. 文件起始位置
      4. 录音字节数
返回: 开始录音前数据文件的长度 (返回 -1 表示文件录音失败)
说明: 如果数据文件不存在, 则被自动建立, 如果要将录音数据追加到文件尾, 可将参数 3 设置成
      LONG_MAX (MAXLONG).各个通道可以互相独立地进行文件录音, 缺省状态下, 录音过程中文件
      一直处于打开状态, 因此在多个通道同时进行文件录音时, 要保证有足够的资源来打开多个文
      件, 请参阅相应的<C语言编译器手册>及<操作系统手册>; 也可以将变量TV_CloseFile 设置成
      1, 这样, 录音过程中文件将处于关闭状态, 只有要写文件时才将它打开, 此时, 任意多个通
      道都可以同时进行文件录音

      使用 Telewind 系列电话卡所录制的语音数据文件的格式都是标准 A 律
      PCM 码或者 ADPCM 码, 文件扩展名统一规定为 TW, 例如: "HELLO.TW"

long	TV_RecordFileRest (int);
--------------------------------
功能: 查询文件录音中没有录完的字节数
参数: 通道号
返回: 没有录完的字节数 (返回 -1 表示文件录音失败)
说明: 应用程序必须随时调用 TV_RecordFileRest(...) 来查询文件录音是否结束, 这样才能保证文
      件录音的连续性.

long	TV_StopRecordFile (int);
--------------------------------
功能: 强制停止某一通道的文件录音
参数: 通道号
返回: 没有录完的字节数

long	TV_StartPlayFile (int, char *, long, long);
---------------------------------------------------
功能: 对某一通道进行文件放音
参数: 1. 通道号
      2. 数据文件名
      3. 文件起始位置
      4. 放音字节数
返回: 实际放音的长度 (返回 -1 表示文件放音失败)
说明: 如果要对全部数据文件进行放音, 可将参数 4 设置成 LONG_MAX (MAXLONG). 各个通道可以互
      相独立地进行文件放音, 缺省状态下, 放音过程中文件一直处于打开状态, 因此在多个通道同
      时进行文件放音时, 要保证有足够的资源来打开多个文件, 请参阅相应的<C语言编译器手册>
      及<操作系统手册>; 建议事先运行 SMARTDRV 提高读盘速度

long	TV_PlayFileRest (int);
------------------------------
功能: 查询文件放音中没有放完的字节数
参数: 通道号
返回: 没有放完的字节数 (返回 -1 表示文件放音失败)
说明: 应用程序必须随时调用 TV_PlayFileRest(...) 来查询文件放音是否结束, 这样才能保证文
      件放音的连续性

long	TV_StopPlayFile (int);
------------------------------
功能: 强制停止某一通道的文件放音
参数: 通道号
返回: 没有放完的字节数

void	TV_MakeSentence (double, char *);
-----------------------------------------
功能: 将念一个双精度浮点数的语句以 CHAR_NAME 形式转换到一个语句字符串中
参数: 1. 双精度浮点数
      2. 语句字符串
返回: 无
说明: 如果要在放音时自动念出一个数, 可先转换到一个字符串中, 如果有必要, 还可以再对字符
      串进行处理, 然后调用 TV_PlaySentence(...) 进行放音.
      双精度浮点数的范围是: 大于负一万亿 (-10^12), 小于一万亿 (10^12)

long	TV_PlaySentence (int, char *);
--------------------------------------
功能: 开始对 TV_MakeSentence 所转换的语句字符串进行放音
参数: 1. 通道号
      2. 语句字符串
返回: 语句字符串中所有语音数据的字节数 (-1 : 失败)
说明: 在调用函数前, 在DOS下，必须先设置 TV_VoiceData 和TV_VoiceLen      如果 TV_VoiceData 
      中包含有文件名, 那么返回字节数是不精确的.在WIN95，WINNT下，请调用TV_SetVoicei来设置
      语音文件。调用函数 TV_StopPlayFile (...) 可以强行中止放音

long	TV_PlaySentenceRest (int);
----------------------------------
功能: 判断某一通道的语句字符串放音是否结束
参数: 通道号
返回: 剩余的字节数 (0 : 放音结束)
说明: 应用程序必须循环调用此函数来检测放音是否结束
      如果 TV_VoiceData 中包含有文件名, 那么返回字节数是不精确的

四．通道连接交换函数:

注意: 当通道 1 连接到通道 2 之后, 那么:
      1. 如果对通道 2 进行自动拨号, 则通道 1 至通道 2 的连接被自动切断
      2. 如果对通道 2 进行放音操作, 则通道 1 至通道 2 的连接被自动切断
      3. 如果对通道 2 产生信号音,   则通道 1 至通道 2 的连接被自动切断

void	TV_ConnectChannels (int, int);
--------------------------------------
功能: 将某两个通道互相连通
参数: 1. 通道号 1
      2. 通道号 2
返回: 无

void	TV_DisconnectChannels (int, int);
-----------------------------------------
功能: 断开由 TV_ConnectChannels(...) 所连通的某两个通道
参数: 1. 通道号 1
      2. 通道号 2
返回: 无

void	TV_ConnectTo (int, int);
--------------------------------
功能: 将某一通道单方向连通到另一个通道
参数: 1. 通道号 1
      2. 通道号 2
返回: 无
说明: 在需要三方通话时, 可以调用函数 TV_ConnectTo(...) 将通道1连到通道2, 通道2连到通道3,
      通道3连到通道1

void	TV_Disconnect (int);
----------------------------
功能: 断开由 TV_ConnectTo(...) 所连通的第二个通道
参数: 通道号
返回: 无


五．与信号音有关的函数:

int	TV_CheckSignal (int, int *, int *);
-------------------------------------------
功能: 查询某一通道的信号音结果 (一般来说只查询外线通道)
参数: 1. 通道号
      2. 返回<信号音个数>变量指针
      3. 返回<信号音长度>变量指针 (单位: 40 ms)
返回: 信号音查询结果 (参阅<系统常量定义>)

说明: 如果需要在某一段时间内检查信号音, 则在开始检查前先调用一次函数TV_StartTimer(...),
      那么如果在超出定时时间后还检测到 SIG_UNKNOWN, 那么 SIG_TIMEOUT 将被返回, 如果应用
      程序不需要超时检查, 那么可以对 SIG_TIMEOUT 和 SIG_UNKNOWN 进行相同的处理;
      返回 SIG_UNKNOWN 表示没有检测到任何一种信号音, 此时返回的<信号音个数>为最近信号音
      方波的低信号音的时间(40ms), 返回的<信号音长度>为高信号音的时间(40ms), 这两个参数可
      以用来判断其他的信号音状态;如果返回 SIG_SILENCE 或 SIG_DIAL, 则返回的<信号音长度>
      为无信号音或拨号音已经持续的时间(40ms);如果返回值为 0 到 (SIGNAL_TYPE - 1), 则返回
      的<信号音个数>为检测到的信号音个数, 返回的<信号音长度>为信号音的总时间长度(40ms)
      在DOS操作系统中最好使用TV_MonitorBusy(...)函数。
      在WIN95/98/NT最好使用该函数

      请参看函数 TV_MonitorBusy(...)

int	TV_ListenerOffHook (int);
---------------------------------
功能: 在控制某一外线通道摘机并调用 TV_StartDial(...) 自动拨号之后, 此函数
      可以用来查询被呼叫方是否已经摘机
参数: 通道号
返回: 0 : 被呼叫方没有摘机; 非 0 : 被呼叫方已经摘机
说明: 使用此函数时, 必须要求外线通道所连接的市内电话线路具有<极性反转>的功能, 此功能可以
      由用户向电话局申请. 如电话线路不具备<极性反转>功能, 那么本函数的返回值恒为 0, 此时
      应用程序就只能通过调用函数TV_MonitorOffHook(...) 来判断被呼叫方是否已经摘机, 从而
      进行下一步的操作. 另外, 在调用此函数前, 必须调用 TV_StartDial(...) 自动拨号, 如果
      需要, 拨号字符串的长度可以为 0

void	TV_StartMonitor (int);
------------------------------
功能: 开始监视被叫方的摘机状态
参数: 通道号
返回: 无
说明: 在完成拨号后, 必须调用一次本函数, 然后即可调用 TV_MonitorOffHook(...)来监视被叫方是否摘机

      请参看范例程序 TVCALL.C

int	TV_MonitorOffHook (int, int);
-------------------------------------
功能: 监视被叫方是否摘机
参数: 1. 通道号
      2. 回铃音嘟声的时间长度 (单位: 40ms)
	 一般回铃音嘟声的时间长度是 1 秒, 因此本参数的值应为 25
返回: 0 : 被叫方没有摘机
      非 0 : 被叫方已摘机
说明: 本函数是根据信号音来判断被叫方的摘机状态, 如果被叫方摘机后有说话的声音, 那么返回
      结果会很及时, 否则, 返回结果会稍有延迟, 但是延迟时间最多不超过 4 秒
      在WIN98/2K中最好使用TV_CheckSignal函数。

      请参看范例程序 TVCALL.C

int	TV_MonitorBusy (int, int, int);
---------------------------------------
功能: 根据忙音监视挂机状态
参数: 1. 通道号
      2. 忙音信号音类型
      3. 忙音个数
返回: 0 : 没有监视到指定个数的忙音
      非 0 : 监视到指定个数的忙音, 即对方已挂机
说明: 某一路外线在放音时, 对方挂机, 线路上出现忙音, 调用本函数来监视挂机状态忙音信号音
      可以是 SIG_BUSY1 或 SIG_BUSY2, 忙音个数一般可以指定为 3 或 4, 根据实际情况可以适
      当调整, 但是如果个数太小, 有可能会出现误判, 如果个数太大, 则有可能检测不到。
      TV_CheckSignal也可完成该功能。

      请参看范例程序 TVCALL.C 及 LISTEN.C

六．其他函数:

void	TV_StartTimer (int, long);
----------------------------------
功能: 开始某一通道的计时器
参数: 1. 通道号
      2. 定时器时间 (单位: 秒)
说明: 计时器一般在信号音检测中用来定时. 如果需要, 也可和 TV_TimerElapsed(...)配合起来
      用在其他场合. 定时器的误差小于 1 秒.

long	TV_TimerElapsed (int);
------------------------------
功能: 查询某一通道的计时器开始后已走过的时间 (单位: 秒)
参数: 通道号
说明: 如果返回 -1, 则表示已超过定时器时间

void	TV_SysPara (SP_STRUC far *);
------------------------------------
功能: 获取系统参数
参数: 系统参数结构指针
返回: 无
说明: 请参阅<系统参数结构>

void	TV_CompressRatio (int);(目前只提供RATE_64K的压缩比)
-------------------------------
功能: 设置录放音的压缩比
参数: 压缩比
返回: 无
说明: 所设置的压缩比对所有的通道都有效, 并且在某一压缩比下的录音数据必须以相同的压缩比
      来放音, 否则就会放出噪音.

void	TV_GetSerial (char far *);
----------------------------------
功能: 取出 USBID 的序列号
参数: 存放序列号的字符串指针
返回: 无
说明: 每一块 USBID 电话卡对应于唯一的 8 位序列号, 如 "95800001".

七．新增函数:
int     TV_ReceiveCallingID (int , char far *,int);
---------------------------------------------------
功能: 取出主叫号码
参数: 通道号
      存放主叫号码的字符串指针
	  字符串长度
返回: 接收的字符数
说明: 接收主叫号可在振铃之前或第一声振铃之后，由邮局设置。而且必须在交换局申请此功能。
	主叫号码最长为MAX_CALLINGID_LEN(24)


void   TV_SetSignalLevel( int );
--------------------------------
功能: 设置检测信号音强度域值
参数: 0--3 由弱到强
说明: 在不使用特定频率检测信号音时,使用该函数


void   TV_SetVoicei(int ,char far *);
-------------------------------------
功能: 设置对应的多文件
参数: 
说明: WIN95,WINNT专用函数      
      例如:
        TV_SetVoicei 0,""
        TV_SetVoicei 1,""
        TV_SetVoicei 2,"D0.TW"
        TV_SetVoicei 3,"D1.TW"
        .
        .
        .
        TV_SetVoicei 18,"NEGATIVE.TW"
        TV_SetVoicei 19,"THANKS.TW"
        .
        .
    以上设置为函数TV_MakeSentence服务，可将数值123转化为一百二十三。用户可从19往后设置自己要放的语音文件，如播放年月日期等。

int   TV_GetLastError() ;
---------------------------------
功能: 取得最后一次的错误代码
参数: 无
说明: 所有有返回的函数失败返回为-1，再调用该函数返回具体的错误代码取得错误代码后，可查看USBID.H中的错误代码声明。

        E_DRIVER        0xff    -1  USBID 驱动没有起来		(TV_Installed调用结果)
        E_OK            0x00    0   没有错误
        E_COMMAND       0x01    1   错误命令/
        E_LENGTH        0x02    2   缓冲区过大
        E_PLAY_RECORD   0x03    3   放音与录音冲突
        E_CHANNEL       0x04    4   错误的通道号
        E_ARGUMENT      0x05    5   参数错误
        E_ERR_SYNC      0x6     6   
        E_OUT_OF_MEMORY 0x7     7   内存溢出
        E_ERR           0x8     8
        E_RECORD_BUSY   0x9     9   录音忙 
        E_FILEOPEN      0xa     10  文件打开错误
        E_PLAY_BUSY     0xb     11  放音忙

void   TV_SetSignalParam( int , int , int ,int ,int );
--------------------------------------------------------
功能: 用户自定义信号音
参数: 1  信号音变量(0 SIG_RING, 1 SIG_BUSY1, 2 SIG_BUSY2已设置)
         用户从3开始设起
      2  信号音零值 时间最小范围值
      3  信号音零值 时间最大范围值
      4  信号音峰值 时间最小范围值
      5  信号音峰值 时间最大范围值
说明: WIN95,WINNT专用函数设置之后,调用TV_CheckSignal看看有无返回信号音变量3,4...   
	缺省值: [SIG_RING ][] = 90,110, 22, 28   (4,1 秒)
		[SIG_BUSY1][] =  7, 11,  7, 11   (0.35, 0.35 秒)
		[SIG_BUSY2][] = 11, 14, 11, 14   (0.5, 0.5 秒)

void   TV_SetDTMFSendSpeed( int , int );
-----------------------------------------------
功能: 设置发送DTMF码速度
参数: 1  通道号
      2  0  快速 64ms
         1  中速 128ms
         2  慢速 256ms

说明: 对外线拨号用慢速。专用收发号可用快速。

void	TV_EnableFSK( int , int ); /* *****98.11.19 */
------------------------------------
功能: 音控模块(对内线而言)以何种方式收取主叫号码
参数: 1  通道号
      2  0 关闭      1 打开
说明: 音控模块无法自动识别FSK方式主叫号码，需设置。

void	TV_SetSendMode( int ch, int m);	/* ******98.11.23 */
---------------------------------------------
功能: 设置拨号方式
参数: 1  通道号
      2  0	DTMF	音频
         1      PLUSE   脉冲
说明: 

int  TV_SetOcTime(int t)		/* ***********98,1,20 */
------------------------------
功能: 设置拍叉簧的时间
参数: t 为时间, 应在80-2000之间,单位为ms. 
说明:  系统初始设置为500毫秒. 

int  TV_SetOcInterval(int omin,int omax)
-----------------------------------------
功能: 设置检测拍叉簧的时间间隔.
参数: 1 时间最少值     omin最小为200,单位ms.
          2 时间最大值      omax最大为3000,单位ms.
说明:  omin必须小于omax,

int TV_OcDetect(int ch)
---------------------------
功能: 检测通道ch是否有拍叉簧动作.
参数: 1 通道号
返回：1表示有,否则返回0.
说明: 返回1以后, 复位, 接下去的TV_OcDetect返回0, 直到有下一次的
      拍叉簧为止.

int	 TV_SetAmp(int v);	// 20 -- 80
---------------------------
功能: 设置信号音检测灵敏度
参数: 范围 20-80   通常为40
返回：
说明: 如遇到信号音较弱，检测不出信号音，则减小参数
      否则，加大参数。


int  TV_GetAdapterBuffer(int, char *, int)
-----------------------------------------

功能: 取得卡上FSK缓冲区内容
参数: 1 通道号 2 缓冲区   3 长度
返回：得到的字节数
说明: 缓冲区为2048字节。
      

int TV_SetAdapterParam(int which,int v)
---------------------------------------
功能：设置语音卡接收主叫号码方式。
参数：which=1，设置DTMF主叫号码获取方法。
      
        v=0，正常方法，DxxxxAxxxxC格式。
        v=1，无格式，全取。
返回：错误代码

int TV_SetChannelFreq(int ch,int Hz)
--------------------------------------
功能：设置通道所用的信号音频率，可动态改变。
参数：1：通道号
      2：频率 （如450HZ）
返回：错误代码


long	TV_StartRecord2 (int, char far *, int);
------------------------------------------------
功能: 用于不间断录音
参数: 1. 通道号
      2. 录音缓冲区指针
      3. 录音字节数 (小于 64K)
返回: 还没有录完的字节数
说明：第一次调用TV_StartRecord，在TV_RecordRest返回字节数为32K字节时，
     调用该函数重新启动录音。
